/****************************************

	ClassActionPrefs Source

	(c) by 1995 Salim Gasmi

	File : Disk.c

	Goal : Load/Save Functions

	Ver  : 3.00

****************************************/

#include <fcntl.h>
#include <exec/types.h>
#include <exec/exec.h>
#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>
#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <string.h>
#include <stdio.h>

#include "includes.h"

#define SFILE "ENVARC:ClassAction/ClassAction.prefs"
#define SFILET "ENV:ClassAction/ClassAction.prefs"
#define GFILE "ENVARC:ClassAction/ClassAction_Gen.prefs"
#define GFILET "ENV:ClassAction/ClassAction_Gen.prefs"
#define DFILE "ENVARC:ClassAction/ClassAction_Dir.prefs"
#define DFILET "ENV:ClassAction/ClassAction_Dir.prefs"

#define EOC "CLASS_END"
#define EOSF "FILE_END"

#define SHEADER "CAFS20"
#define GHEADER "CAFG20"
#define DHEADER "CAFD30"

FILE *f;

void Wr(char *s)
{
	fputs(s, f);
	fputs("\n", f);
}

void Re(char *s)
{
	static fuck = 0;

	if (fgets(s, 256, f) == NULL)
	{
		strcpy(s, "???");
		if (fuck == 0)
		{
			fuck = 1;
			RInfo(LocaleMsg[CAP_CONFIG_CORRUPT]);
		}
	}
	else
		s[strlen(s) - 1] = 0;
}

int SaveMem(int flag)
{

	struct Class *cla;
	struct Action *act;
	int i;
	char tmp[20];
	char savefile[30];
	int l, h;
	char *buf;

	if (flag == 0)
		strcpy(savefile, SFILET);
	if (flag == 1)
		strcpy(savefile, SFILE);

	f = fopen(savefile, "w");
	if (f == NULL)
		return (-1);

	Wr(SHEADER);

	/* Writing Unknown Class */

	cla = MemList.head;
	act = cla->action;

	Wr(UNKNOWN);

	while (act != NULL)
	{
		Wr(act->name);
		Wr(act->exec);
		sprintf(tmp, "%d", act->wbrun);
		Wr(tmp);
		sprintf(tmp, "%s,%s", act->stack, act->delay);
		Wr(tmp);
		act = act->next;
	}
	Wr(EOC);

	/* Skipping Generic Class && Dir Class */

	cla = cla->next->next->next;

	/* Writing File */

	while (cla != NULL)
	{
		Wr(cla->name);
		Wr(cla->suffix);
		for (i = 0; i < 5; i++)
			Wr(cla->value[i]);
		act = cla->action;
		while (act != NULL)
		{
			Wr(act->name);
			Wr(act->exec);
			sprintf(tmp, "%d", act->wbrun);
			Wr(tmp);
			sprintf(tmp, "%s,%s", act->stack, act->delay);
			Wr(tmp);
			act = act->next;
		}
		Wr(EOC);
		cla = cla->next;
	}

	Wr(EOSF);
	Wr(" ");
	Wr("************************************************");
	Wr(" ");
	Wr("This file has been generated by ClassActionPrefs");
	Wr("(c) 1994-1995 by Gasmi Salim");
	Wr(" ");
	Wr("************************************************");
	Wr("$VER: ClassAction Definition File");
	fclose(f);

	/* Saving Generic file */

	if (flag == 0)
		strcpy(savefile, GFILET);
	if (flag == 1)
		strcpy(savefile, GFILE);

	f = fopen(savefile, "w");
	act = Generic.action;

	Wr(GHEADER);

	while (act != NULL)
	{
		Wr(act->name);
		Wr(act->exec);
		sprintf(tmp, "%d", act->wbrun);
		Wr(tmp);
		sprintf(tmp, "%s,%s", act->stack, act->delay);
		Wr(tmp);
		act = act->next;
	}
	Wr(EOC);
	Wr("$VER: ClassAction Generic Actions File");
	fclose(f);

	/* Saving Directory file */

	if (flag == 0)
		strcpy(savefile, DFILET);
	if (flag == 1)
		strcpy(savefile, DFILE);

	f = fopen(savefile, "w");
	act = Directory.action;

	Wr(DHEADER);

	while (act != NULL)
	{
		Wr(act->name);
		Wr(act->exec);
		sprintf(tmp, "%d", act->wbrun);
		Wr(tmp);
		sprintf(tmp, "%s,%s", act->stack, act->delay);
		Wr(tmp);
		act = act->next;
	}
	Wr(EOC);
	Wr("$VER: ClassAction Directory Actions File");
	fclose(f);

	if (flag == 1)
	{
		h = open(SFILE, O_RDONLY);
		if (h < 0)
			return (0);
		l = lseek(h, 0, 2);
		lseek(h, 0, 0);
		buf = (char *)malloc(l);
		if (buf == NULL)
		{
			close(h);
			return (0);
		}
		read(h, buf, l);
		close(h);
		h = open(SFILET, O_WRONLY | O_CREAT);
		write(h, buf, l);
		close(h);
		free(buf);

		h = open(GFILE, O_RDONLY);
		if (h < 0)
			return (0);
		l = lseek(h, 0, 2);
		lseek(h, 0, 0);
		buf = (char *)malloc(l);
		if (buf == NULL)
		{
			close(h);
			return (0);
		}
		read(h, buf, l);
		close(h);
		h = open(GFILET, O_WRONLY | O_CREAT);
		write(h, buf, l);
		close(h);
		free(buf);

		h = open(DFILE, O_RDONLY);
		if (h < 0)
			return (0);
		l = lseek(h, 0, 2);
		lseek(h, 0, 0);
		buf = (char *)malloc(l);
		if (buf == NULL)
		{
			close(h);
			return (0);
		}
		read(h, buf, l);
		close(h);
		h = open(DFILET, O_WRONLY | O_CREAT);
		write(h, buf, l);
		close(h);
		free(buf);
	}

	NotifyMaster();
	return (0);
}

int LoadMem(void)
{
	struct Class *cla;
	struct Action *act;
	char ch[256];
	int i;
	int out;
	char tmp[20];
	char *ppp;

	/* Allocating the Unknown Class */

	cla = (struct Class *)malloc(sizeof(struct Class));

	cla->next = NULL;
	cla->action = cla->actiontail = NULL;
	cla->nbaction = 0;
	cla->suffix[0] = NULL;
	for (i = 0; i < 5; i++)
		cla->value[i][0] = NULL;

	MemList.head = MemList.tail = cla;
	MemList.size++;

	/* End of Allocation */

	f = fopen(SFILET, "r");
	if (f == NULL)
		f = fopen(SFILE, "r");
	if (f == NULL)
		return (-1);

	Re(ch);
	if (strcmp(ch, SHEADER) != 0)
	{
		RInfo(LocaleMsg[CAP_CONFIG_NOT_VALID]);
		fclose(f);
		return (-2);
	}

	Re(cla->name);
	strcpy(cla->name, UNKNOWN);

	/* reading Unknown Actions */

	out = 0;
	while (out == 0)
	{
		Re(ch);
		if (strcmp(ch, EOC) != 0)
		{
			act = (struct Action *)malloc(sizeof(struct Action));
			act->next = NULL;

			if (cla->action == NULL)
				cla->action = cla->actiontail = act;
			else
			{
				cla->actiontail->next = act;
				cla->actiontail = act;
			}
			cla->nbaction++;
			strcpy(act->name, ch);
			Re(act->exec);
			Re(tmp);
			act->wbrun = atoi(tmp);
			Re(tmp);
			ppp = strstr(tmp, ",");
			if (ppp == NULL)
			{
				strcpy(act->stack, tmp);
				strcpy(act->delay, "-1");
			}
			else
			{
				*ppp = 0;
				strcpy(act->stack, tmp);
				strcpy(act->delay, ppp + 1);
			}
		}
		else
			out = 1;
	}

	/* Starting reading File */

	while (1)
	{
		Re(ch);
		if (strcmp(ch, EOSF) == 0)
		{
			fclose(f);
			return (0);
		}
		cla = (struct Class *)malloc(sizeof(struct Class));

		cla->next = NULL;
		cla->action = cla->actiontail = NULL;
		cla->nbaction = 0;

		MemList.tail->next = cla;
		MemList.tail = cla;
		MemList.size++;
		strcpy(cla->name, ch);
		Re(cla->suffix);
		for (i = 0; i < 5; i++)
			Re(cla->value[i]);
		out = 0;
		while (out == 0)
		{
			Re(ch);
			if (strcmp(ch, EOC) != 0)
			{
				act = (struct Action *)malloc(sizeof(struct Action));
				act->next = NULL;

				if (cla->action == NULL)
					cla->action = cla->actiontail = act;
				else
				{
					cla->actiontail->next = act;
					cla->actiontail = act;
				}
				cla->nbaction++;
				strcpy(act->name, ch);
				Re(act->exec);
				Re(tmp);
				act->wbrun = atoi(tmp);
				Re(tmp);
				ppp = strstr(tmp, ",");
				if (ppp == NULL)
				{
					strcpy(act->stack, tmp);
					strcpy(act->delay, "-1");
				}
				else
				{
					*ppp = 0;
					strcpy(act->stack, tmp);
					strcpy(act->delay, ppp + 1);
				}
			}
			else
				out = 1;
		}
	}

	return (0);
}

int SortList()
{
	struct Class *cla, *prev, *buf, dum;
	int i, f, n, out;

	n = MemList.size;
	if (n < 3)
		return (0);

	buf = (struct Class *)malloc(sizeof(struct Class) * n);

	cla = MemList.head;
	for (i = 0; i < n; i++)
	{
		buf[i] = *cla;
		cla = cla->next;
	}

	out = 0;
	while (out == 0)
	{
		f = 0;
		for (i = 1; i < n - 1; i++)
			if (strcmp(buf[i].name, buf[i + 1].name) > 0)
			{
				dum = buf[i];
				buf[i] = buf[i + 1];
				buf[i + 1] = dum;
				f = 1;
			}
		if (f == 0)
			out = 1;
	}

	cla = MemList.head->next;
	for (i = 1; i < n; i++)
	{
		prev = cla->next;
		*cla = buf[i];
		cla->next = prev;
		cla = prev;
	}

	free(buf);
	return (0);
}

int LoadGen()
{

	struct Action *act;
	struct Class *cla;
	char ch[256];
	char tmp[20];
	int i, out = 0;
	char *ppp;

	strcpy(Generic.name, LocaleMsg[CAP_GENERIC]);
	Generic.nbaction = 0;
	Generic.actiontail = Generic.action = NULL;
	for (i = 0; i < 5; i++)
		Generic.value[i][0] = NULL;
	Generic.suffix[0] = NULL;

	cla = &Generic;

	f = fopen(GFILET, "r");
	if (f == NULL)
		f = fopen(GFILE, "r");
	if (f == NULL)
		return (-1);

	Re(ch);
	if (strcmp(ch, GHEADER) != 0)
	{
		RInfo(LocaleMsg[CAP_GENERIC_NOT_VALID]);
		return (-1);
	}

	while (out == 0)
	{
		Re(ch);
		if (strcmp(ch, EOC) != 0)
		{
			act = (struct Action *)malloc(sizeof(struct Action));
			act->next = NULL;

			if (cla->action == NULL)
				cla->action = cla->actiontail = act;
			else
			{
				cla->actiontail->next = act;
				cla->actiontail = act;
			}
			cla->nbaction++;
			strcpy(act->name, ch);
			Re(act->exec);
			Re(tmp);
			act->wbrun = atoi(tmp);
			Re(tmp);
			ppp = strstr(tmp, ",");
			if (ppp == NULL)
			{
				strcpy(act->stack, tmp);
				strcpy(act->delay, "-1");
			}
			else
			{
				*ppp = 0;
				strcpy(act->stack, tmp);
				strcpy(act->delay, ppp + 1);
			}
		}
		else
			out = 1;
	}
	fclose(f);

	/* Reading Dir File */

	strcpy(Directory.name, LocaleMsg[CAP_DIRECTORY]);
	Directory.nbaction = 0;
	Directory.actiontail = Directory.action = NULL;
	for (i = 0; i < 5; i++)
		Directory.value[i][0] = NULL;
	Directory.suffix[0] = NULL;

	cla = &Directory;

	f = fopen(DFILET, "r");
	if (f == NULL)
		f = fopen(DFILE, "r");
	if (f == NULL)
		return (-1);

	Re(ch);
	if (strcmp(ch, DHEADER) != 0)
	{
		RInfo(LocaleMsg[CAP_DIR_NOT_VALID]);
		return (-1);
	}
	out = 0;

	while (out == 0)
	{
		Re(ch);
		if (strcmp(ch, EOC) != 0)
		{
			act = (struct Action *)malloc(sizeof(struct Action));
			act->next = NULL;

			if (cla->action == NULL)
				cla->action = cla->actiontail = act;
			else
			{
				cla->actiontail->next = act;
				cla->actiontail = act;
			}
			cla->nbaction++;
			strcpy(act->name, ch);
			Re(act->exec);
			Re(tmp);
			act->wbrun = atoi(tmp);
			Re(tmp);
			ppp = strstr(tmp, ",");
			if (ppp == NULL)
			{
				strcpy(act->stack, tmp);
				strcpy(act->delay, "-1");
			}
			else
			{
				*ppp = 0;
				strcpy(act->stack, tmp);
				strcpy(act->delay, ppp + 1);
			}
		}
		else
			out = 1;
	}

	fclose(f);
	return (0);
}

int GetReg(char *user)
{

	int h;
	int i;
	unsigned char x;
	int cs;
	int l;

	h = open("s:CA.key", O_RDONLY);
	if (h < 0)
		return (-1);

	cs = 0;
	for (i = 0; i < 200; i++)
	{
		read(h, &x, 1);
		cs = cs + x;
	}

	read(h, &x, 1);
	cs = cs % 256;
	if (x != cs)
	{
		close(h);
		return (-1);
	}

	read(h, &x, 1);
	l = x;

	cs = 0;
	for (i = 0; i < l; i++)
	{
		read(h, &x, 1);
		cs = cs + x;
		user[i] = x - 85 - i;
	}

	user[l] = 0;
	read(h, &x, 1);
	cs = cs % 256;
	if (cs != x)
	{
		close(h);
		return (-3);
	}

	cs = 0;
	for (i = 0; i < 200; i++)
	{
		read(h, &x, 1);
		cs = cs + x;
	}

	read(h, &x, 1);
	cs = cs % 256;
	if (x != cs)
	{
		close(h);
		return (-2);
	}

	close(h);
	return (0);
}
